---
layout: page
title: Design
permalink: /design/
---

# Microcontroller Design

As mentioned above, the MCU will be used to control the stepper motor that will move the slide whistle to play different notes. The block diagram for the wiring of the MCU with the A4988 stepper motor driver and the stepper motor itself is shown in Appendix B. The MCU provides two main control signals to the stepper motor driver: the direction and steps. The direction pin is either high or low to indicate direction, and for each pulse sent to the step pin the motor moves one step. In order to send a known number of pulses at a certain rate, we use the timer 16 peripheral in one-shot PWM mode together with the repetition counter set to the desired number of pulses (Appendix C). All that is required now to move the slide whistle to the desired position to play notes is the physical gearing and a calibration curve to relate frequency to a position along the slide whistle. 


# FPGA Design

As mentioned above, the FPGA is capable of displaying characters on the LCD. It is set up using the schematic shown in figure 1. The LCD in this case uses a Hitachi HD44780U LCD controller chip. The FPGA was implemented in a way that could mimic what was described in this controller’s datasheet [ref](https://circuitdigest.com/sites/default/files/HD44780U.pdf). This involved creating two finite state machines. The first FSM, used to send data to the screen, works as follows: it waits for data to come in from the controller FSM, indicated by a dataReady signal rising to 1. Then it goes through the steps to send the inputs of the correct RS, R/W, Data, and Enable signals to the LCD controller. Once it is done, it raises a 'sendCharDone' signal back to the controller FSM to indicate that the transaction is complete and a new one can be made. This FSM then sits in a wait state again until the controller sends more data.

The controller FSM is rather more complicated, as it has to decide the setup signals being sent to the LCD and time all the data correctly. It begins in an initial state, where it waits until a counter has gone past a value corresponding to 40ms. This is due to a 40ms startup time described by the LCD controller [ref](https://circuitdigest.com/sites/default/files/HD44780U.pdf). Then, this controller FSM sends two setup signals to the LCD to set the correct configuration registers  in the LCD. These set up the LCD as having 16 lines of 2 characters and to incriment the cursor each time a character is written. Then the controller FSM goes into a wait state until it receives data from the MCU over SPI. When the SPI transaction is done, the controller sends a control signal to the LCD that puts the cursor in the correct position for either the title or the note. Finally, the control FSM sends all the title or note characters to the LCD. Once all the characters are sent, the control FSM goes back to the wait state to await the next chunk of data from the MCU. This entire operation relies on several counter variables that count the number of characters sent or the time passed. Each time a character is sent to the LCD, the character sender FSM is activated and the controller FSM remains in the same state until the transaction is complete. This is true for both control character signals and data characters being displayed on the screen. 

The FPGA receives the correct data to display on the screen via an SPI transaction with the MCU as controller and FPGA as peripheral. Data only needs to go from controller to peripheral, so the CIPO line is ignored. The SPI reception module in the FPGA listens for transactions using an spiLoad signal from the MCU. Another signal, titleNote, is used to indicate whether the transaction is sending new title data or new note data. The FPGA detects when the spiLoad signal has dropped as an indication that data transfer is done and the title or note are ready to send to the screen. One issue with this is that the clock for the controller and datasend FSMs must be fairly slow. this is due to the fact that most of the commands to the screen take 37 μs [ref](https://circuitdigest.com/sites/default/files/HD44780U.pdf). This slow clock was divided down from a 48M MHz fast clock. The problem with this is that the spiLoad signal may rise and fall within less than a slow clock cycle, which means it would not be detected on the rising edge of the clock. To remedy this, a third synchronizing FSM was created. This one used the fast 48 MHz to make sure the spiLoad signal was captured. Then, since the ratio of fast and slow clock frequencies was known, this FSM was used to hold an spiDone outut signal until it could be detected by the slow clock. The data from the SPI transaction is held after it is done and the transactions come every several hundred ms, so there is no need to synchronize that data. In this way, all the information coming out of SPI is synchronized to the slower clock of the other FSMs. 

# Hardware Design

The slide whistle has a 3D printed attachment from the fan to the mouthpiece of the whistle. This allows all the air coming out of the fan to be sent into the whistle and works fairly well to play notes along the entire length of the whistle slide. A new one may have to be printed that allows 2 fans to attach to the whistle for more air power if need be. 
The gearing for the motor is still yet to be printed but should be fairly simple. It will involve a rack that will be attached to the slider of the whistle. This will be attached to gears that are driven by the motor. Because the motor is a stepper motor, it can be relied upon to give a specific distance of movement per step. When all the gears and other attachments are printed, the positions of the slide will be mapped to the notes being played. This, combined with the current position of the stepper motor, can be combined in the MCU to get the number of steps and the direction of the motor necessary to move the slide whistle to the correct next note, as described above. 
